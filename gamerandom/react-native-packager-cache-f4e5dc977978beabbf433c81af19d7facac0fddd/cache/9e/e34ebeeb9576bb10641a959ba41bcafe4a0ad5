/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactCompositeComponent
 */

'use strict';

var React=require('react');
var ReactComponentEnvironment=require('ReactComponentEnvironment');
var ReactCompositeComponentTypes=require('ReactCompositeComponentTypes');
var ReactErrorUtils=require('ReactErrorUtils');
var ReactFeatureFlags=require('ReactFeatureFlags');
var ReactInstanceMap=require('ReactInstanceMap');
var ReactInstrumentation=require('ReactInstrumentation');
var ReactNodeTypes=require('ReactNodeTypes');
var ReactReconciler=require('ReactReconciler');var _require=
require('ReactGlobalSharedState'),ReactCurrentOwner=_require.ReactCurrentOwner;

{var _require2=
require('ReactGlobalSharedState'),ReactDebugCurrentFrame=_require2.ReactDebugCurrentFrame;
var warningAboutMissingGetChildContext={};
}

var checkPropTypes=require('prop-types/checkPropTypes');
var emptyObject=require('fbjs/lib/emptyObject');
var invariant=require('fbjs/lib/invariant');
var shallowEqual=require('fbjs/lib/shallowEqual');
var shouldUpdateReactComponent=require('shouldUpdateReactComponent');
var warning=require('fbjs/lib/warning');

function StatelessComponent(Component){}
StatelessComponent.prototype.render=function(){
var Component=ReactInstanceMap.get(this)._currentElement.type;
var element=Component(this.props,this.context,this.updater);
return element;
};

function shouldConstruct(Component){
return!!(Component.prototype&&Component.prototype.isReactComponent);
}

function isPureComponent(Component){
return!!(Component.prototype&&Component.prototype.isPureReactComponent);
}

// Separated into a function to contain deoptimizations caused by try/finally.
function measureLifeCyclePerf(fn,debugID,timerType){
if(debugID===0){
// Top-level wrappers (see ReactMount) and empty components (see
// ReactDOMEmptyComponent) are invisible to hooks and devtools.
// Both are implementation details that should go away in the future.
return fn();
}

ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID,timerType);
try{
return fn();
}finally{
ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID,timerType);
}
}

/**
 * ------------------ The Life-Cycle of a Composite Component ------------------
 *
 * - constructor: Initialization of state. The instance is now retained.
 *   - componentWillMount
 *   - render
 *   - [children's constructors]
 *     - [children's componentWillMount and render]
 *     - [children's componentDidMount]
 *     - componentDidMount
 *
 *       Update Phases:
 *       - componentWillReceiveProps (only called if parent updated)
 *       - shouldComponentUpdate
 *         - componentWillUpdate
 *           - render
 *           - [children's constructors or receive props phases]
 *         - componentDidUpdate
 *
 *     - componentWillUnmount
 *     - [children's componentWillUnmount]
 *   - [children destroyed]
 * - (destroyed): The instance is now blank, released by React and ready for GC.
 *
 * -----------------------------------------------------------------------------
 */

/**
 * An incrementing ID assigned to each component when it is mounted. This is
 * used to enforce the order in which `ReactUpdates` updates dirty components.
 *
 * @private
 */
var nextMountID=1;

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponent={
/**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
construct:function construct(element){
this._currentElement=element;
this._rootNodeID=0;
this._compositeType=null;
this._instance=null;
this._hostParent=null;
this._hostContainerInfo=null;

// See ReactUpdateQueue
this._updateBatchNumber=null;
this._pendingElement=null;
this._pendingStateQueue=null;
this._pendingReplaceState=false;
this._pendingForceUpdate=false;

this._renderedNodeType=null;
this._renderedComponent=null;
this._context=null;
this._mountOrder=0;
this._topLevelWrapper=null;

// See ReactUpdates and ReactUpdateQueue.
this._pendingCallbacks=null;

// ComponentWillUnmount shall only be called once
this._calledComponentWillUnmount=false;

{
this._warnedAboutRefsInRender=false;
}
},

/**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} hostParent
   * @param {?object} hostContainerInfo
   * @param {?object} context
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
mountComponent:function mountComponent(
transaction,
hostParent,
hostContainerInfo,
context)
{var _this=this;
this._context=context;
this._mountOrder=nextMountID++;
this._hostParent=hostParent;
this._hostContainerInfo=hostContainerInfo;

var publicProps=this._currentElement.props;
var publicContext=this._processContext(context);

var Component=this._currentElement.type;

var updateQueue=transaction.getUpdateQueue();

// Initialize the public class
var doConstruct=shouldConstruct(Component);
var inst=this._constructComponent(
doConstruct,
publicProps,
publicContext,
updateQueue);

var renderedElement;

// Support functional components
if(!doConstruct&&(inst==null||inst.render==null)){
renderedElement=inst;
{
warning(
!Component.childContextTypes,
'%s(...): childContextTypes cannot be defined on a functional component.',
Component.displayName||Component.name||'Component');

}
invariant(
inst===null||inst===false||React.isValidElement(inst),"%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.",


Component.displayName||Component.name||'Component');

inst=new StatelessComponent(Component);
this._compositeType=ReactCompositeComponentTypes.StatelessFunctional;
}else{
if(isPureComponent(Component)){
this._compositeType=ReactCompositeComponentTypes.PureClass;
}else{
this._compositeType=ReactCompositeComponentTypes.ImpureClass;
}
}

{
// This will throw later in _renderValidatedComponent, but add an early
// warning now to help debugging
if(inst.render==null){
warning(
false,"%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.",


Component.displayName||Component.name||'Component');

}

var propsMutated=inst.props!==publicProps;
var componentName=
Component.displayName||Component.name||'Component';

warning(
inst.props===undefined||!propsMutated,"%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",


componentName,
componentName);

}

// These should be set up in the constructor, but as a convenience for
// simpler class abstractions, we set them up after the fact.
inst.props=publicProps;
inst.context=publicContext;
inst.refs=emptyObject;
inst.updater=updateQueue;

this._instance=inst;

// Store a reference from the instance back to the internal representation
ReactInstanceMap.set(inst,this);

{
// Since plain JS classes are defined without any special initialization
// logic, we can not catch common errors early. Therefore, we have to
// catch them here, at initialization time, instead.
warning(
!inst.getInitialState||
inst.getInitialState.isReactClassApproved||
inst.state,"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",



this.getName()||'a component');

warning(
!inst.getDefaultProps||inst.getDefaultProps.isReactClassApproved,"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",



this.getName()||'a component');

warning(
!inst.propTypes,"propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.",


this.getName()||'a component');

warning(
!inst.contextTypes,"contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.",


this.getName()||'a component');

warning(
typeof inst.componentShouldUpdate!=='function',"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",




this.getName()||'A component');

warning(
typeof inst.componentDidUnmount!=='function',"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",



this.getName()||'A component');

warning(
typeof inst.componentWillRecieveProps!=='function',"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",


this.getName()||'A component');

if(
isPureComponent(Component)&&
typeof inst.shouldComponentUpdate!=='undefined')
{
warning(
false,"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",



this.getName()||'A pure component');

}
warning(
!inst.defaultProps,"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",


this.getName()||'a component',
this.getName()||'a component');

}

var initialState=inst.state;
if(initialState===undefined){
inst.state=initialState=null;
}
invariant(
typeof initialState==='object'&&!Array.isArray(initialState),
'%s.state: must be set to an object or null',
this.getName()||'ReactCompositeComponent');


this._pendingStateQueue=null;
this._pendingReplaceState=false;
this._pendingForceUpdate=false;

if(inst.componentWillMount){
{
measureLifeCyclePerf(
function(){return inst.componentWillMount();},
this._debugID,
'componentWillMount');

}


// When mounting, calls to `setState` by `componentWillMount` will set
// `this._pendingStateQueue` without triggering a re-render.
if(this._pendingStateQueue){
inst.state=this._processPendingState(inst.props,inst.context);
}
}

var markup;
if(inst.unstable_handleError){
markup=this.performInitialMountWithErrorHandling(
renderedElement,
hostParent,
hostContainerInfo,
transaction,
context);

}else{
markup=this.performInitialMount(
renderedElement,
hostParent,
hostContainerInfo,
transaction,
context);

}

if(inst.componentDidMount){
{
transaction.getReactMountReady().enqueue(function(){
measureLifeCyclePerf(
function(){return inst.componentDidMount();},
_this._debugID,
'componentDidMount');

});
}


}

// setState callbacks during willMount should end up here
var callbacks=this._pendingCallbacks;
if(callbacks){
this._pendingCallbacks=null;
for(var i=0;i<callbacks.length;i++){
transaction.getReactMountReady().enqueue(callbacks[i],inst);
}
}

return markup;
},

_constructComponent:function _constructComponent(
doConstruct,
publicProps,
publicContext,
updateQueue)
{
{
ReactCurrentOwner.current=this;
try{
return this._constructComponentWithoutOwner(
doConstruct,
publicProps,
publicContext,
updateQueue);

}finally{
ReactCurrentOwner.current=null;
}
}







},

_constructComponentWithoutOwner:function _constructComponentWithoutOwner(
doConstruct,
publicProps,
publicContext,
updateQueue)
{
var Component=this._currentElement.type;

if(doConstruct){
{
return measureLifeCyclePerf(
function(){return new Component(publicProps,publicContext,updateQueue);},
this._debugID,
'ctor');

}


}

// This can still be an instance in case of factory components
// but we'll count this as time spent rendering as the more common case.
{
return measureLifeCyclePerf(
function(){return Component(publicProps,publicContext,updateQueue);},
this._debugID,
'render');

}


},

performInitialMountWithErrorHandling:function performInitialMountWithErrorHandling(
renderedElement,
hostParent,
hostContainerInfo,
transaction,
context)
{
var markup;
var checkpoint=transaction.checkpoint();
try{
markup=this.performInitialMount(
renderedElement,
hostParent,
hostContainerInfo,
transaction,
context);

}catch(e){
// Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
transaction.rollback(checkpoint);
this._instance.unstable_handleError(e);
if(this._pendingStateQueue){
this._instance.state=this._processPendingState(
this._instance.props,
this._instance.context);

}
checkpoint=transaction.checkpoint();
this._renderedComponent.unmountComponent(
true/* safely */,
// Don't call componentWillUnmount() because they never fully mounted:
true/* skipLifecyle */);

transaction.rollback(checkpoint);

// Try again - we've informed the component about the error, so they can render an error message this time.
// If this throws again, the error will bubble up (and can be caught by a higher error boundary).
markup=this.performInitialMount(
renderedElement,
hostParent,
hostContainerInfo,
transaction,
context);

}
return markup;
},

performInitialMount:function performInitialMount(
renderedElement,
hostParent,
hostContainerInfo,
transaction,
context)
{
// If not a stateless component, we now render
if(renderedElement===undefined){
renderedElement=this._renderValidatedComponent();
}

var nodeType=ReactNodeTypes.getType(renderedElement);
this._renderedNodeType=nodeType;
var child=this._instantiateReactComponent(
renderedElement,
nodeType!==ReactNodeTypes.EMPTY/* shouldHaveDebugID */);

this._renderedComponent=child;

var debugID=0;
{
debugID=this._debugID;
}

var markup=ReactReconciler.mountComponent(
child,
transaction,
hostParent,
hostContainerInfo,
this._processChildContext(context),
debugID);


{
if(debugID!==0){
var childDebugIDs=child._debugID!==0?[child._debugID]:[];
ReactInstrumentation.debugTool.onSetChildren(debugID,childDebugIDs);
}
}

return markup;
},

getHostNode:function getHostNode(){
return ReactReconciler.getHostNode(this._renderedComponent);
},

/**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
unmountComponent:function unmountComponent(safely,skipLifecycle){
if(!this._renderedComponent){
return;
}

var inst=this._instance;

if(inst.componentWillUnmount&&!inst._calledComponentWillUnmount){
inst._calledComponentWillUnmount=true;

if(safely){
if(!skipLifecycle){
var name=this.getName()+'.componentWillUnmount()';
ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(
name,
inst.componentWillUnmount,
inst);

}
}else{
{
measureLifeCyclePerf(
function(){return inst.componentWillUnmount();},
this._debugID,
'componentWillUnmount');

}


}
}

if(this._renderedComponent){
ReactReconciler.unmountComponent(
this._renderedComponent,
safely,
skipLifecycle);

this._renderedNodeType=null;
this._renderedComponent=null;
this._instance=null;
}

// Reset pending fields
// Even if this component is scheduled for another update in ReactUpdates,
// it would still be ignored because these fields are reset.
this._pendingStateQueue=null;
this._pendingReplaceState=false;
this._pendingForceUpdate=false;
this._pendingCallbacks=null;
this._pendingElement=null;

// These fields do not really need to be reset since this object is no
// longer accessible.
this._context=null;
this._rootNodeID=0;
this._topLevelWrapper=null;

// Delete the reference from the instance to this internal representation
// which allow the internals to be properly cleaned up even if the user
// leaks a reference to the public instance.
ReactInstanceMap.remove(inst);

// Some existing components rely on inst.props even after they've been
// destroyed (in event handlers).
// TODO: inst.props = null;
// TODO: inst.state = null;
// TODO: inst.context = null;
},

/**
   * Filters the context object to only contain keys specified in
   * `contextTypes`
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
_maskContext:function _maskContext(context){
var Component=this._currentElement.type;
var contextTypes=Component.contextTypes;
if(!contextTypes){
return emptyObject;
}
var maskedContext={};
for(var contextName in contextTypes){
maskedContext[contextName]=context[contextName];
}
return maskedContext;
},

/**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
_processContext:function _processContext(context){
var maskedContext=this._maskContext(context);
{
var Component=this._currentElement.type;
if(Component.contextTypes){
this._checkContextTypes(
Component.contextTypes,
maskedContext,
'context');

}
}
return maskedContext;
},

/**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
_processChildContext:function _processChildContext(currentContext){
var Component=this._currentElement.type;
var inst=this._instance;
var childContext;

if(typeof inst.getChildContext==='function'){
{
ReactInstrumentation.debugTool.onBeginProcessingChildContext();
try{
childContext=inst.getChildContext();
}finally{
ReactInstrumentation.debugTool.onEndProcessingChildContext();
}
}



invariant(
typeof Component.childContextTypes==='object',"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",


this.getName()||'ReactCompositeComponent');

{
this._checkContextTypes(
Component.childContextTypes,
childContext,
'child context');

}
for(var name in childContext){
invariant(
name in Component.childContextTypes,
'%s.getChildContext(): key "%s" is not defined in childContextTypes.',
this.getName()||'ReactCompositeComponent',
name);

}
return babelHelpers.extends({},currentContext,childContext);
}else{
{
var componentName=this.getName();

if(!warningAboutMissingGetChildContext[componentName]){
warningAboutMissingGetChildContext[componentName]=true;
warning(
!Component.childContextTypes,"%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.",



componentName,
componentName);

}
}
}
return currentContext;
},

/**
   * Assert that the context types are valid
   *
   * @param {object} typeSpecs Map of context field to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
_checkContextTypes:function _checkContextTypes(typeSpecs,values,location){
{
ReactDebugCurrentFrame.current=this._debugID;
checkPropTypes(
typeSpecs,
values,
location,
this.getName(),
ReactDebugCurrentFrame.getStackAddendum);

ReactDebugCurrentFrame.current=null;
}
},

receiveComponent:function receiveComponent(nextElement,transaction,nextContext){
var prevElement=this._currentElement;
var prevContext=this._context;

this._pendingElement=null;

this.updateComponent(
transaction,
prevElement,
nextElement,
prevContext,
nextContext);

},

/**
   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
performUpdateIfNecessary:function performUpdateIfNecessary(transaction){
if(this._pendingElement!=null){
ReactReconciler.receiveComponent(
this,
this._pendingElement,
transaction,
this._context);

}else if(this._pendingStateQueue!==null||this._pendingForceUpdate){
this.updateComponent(
transaction,
this._currentElement,
this._currentElement,
this._context,
this._context);

}else{
var callbacks=this._pendingCallbacks;
this._pendingCallbacks=null;
if(callbacks){
for(var j=0;j<callbacks.length;j++){
transaction.
getReactMountReady().
enqueue(callbacks[j],this.getPublicInstance());
}
}
this._updateBatchNumber=null;
}
},

/**
   * Perform an update to a mounted component. The componentWillReceiveProps and
   * shouldComponentUpdate methods are called, then (assuming the update isn't
   * skipped) the remaining update lifecycle methods are called and the DOM
   * representation is updated.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevParentElement
   * @param {ReactElement} nextParentElement
   * @internal
   * @overridable
   */
updateComponent:function updateComponent(
transaction,
prevParentElement,
nextParentElement,
prevUnmaskedContext,
nextUnmaskedContext)
{
var inst=this._instance;
invariant(
inst!=null,"Attempted to update component `%s` that has already been unmounted (or failed to mount).",


this.getName()||'ReactCompositeComponent');


var willReceive=false;
var nextContext;

// Determine if the context has changed or not
if(this._context===nextUnmaskedContext){
nextContext=inst.context;
}else{
nextContext=this._processContext(nextUnmaskedContext);
willReceive=true;
}

var prevProps=prevParentElement.props;
var nextProps=nextParentElement.props;

// Not a simple state update but a props update
if(prevParentElement!==nextParentElement){
willReceive=true;
}

// An update here will schedule an update but immediately set
// _pendingStateQueue which will ensure that any state updates gets
// immediately reconciled instead of waiting for the next batch.
if(willReceive&&inst.componentWillReceiveProps){
var beforeState=inst.state;
{
measureLifeCyclePerf(
function(){return inst.componentWillReceiveProps(nextProps,nextContext);},
this._debugID,
'componentWillReceiveProps');

}


var afterState=inst.state;
if(beforeState!==afterState){
inst.state=beforeState;
inst.updater.enqueueReplaceState(inst,afterState);
{
warning(
false,"%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",



this.getName()||'ReactCompositeComponent');

}
}
}

// If updating happens to enqueue any new updates, we shouldn't execute new
// callbacks until the next render happens, so stash the callbacks first.
var callbacks=this._pendingCallbacks;
this._pendingCallbacks=null;

var nextState=this._processPendingState(nextProps,nextContext);
var shouldUpdate=true;
if(!this._pendingForceUpdate){
var prevState=inst.state;
shouldUpdate=willReceive||nextState!==prevState;
if(inst.shouldComponentUpdate){
{
shouldUpdate=measureLifeCyclePerf(
function(){return inst.shouldComponentUpdate(nextProps,nextState,nextContext);},
this._debugID,
'shouldComponentUpdate');

}






}else{
if(this._compositeType===ReactCompositeComponentTypes.PureClass){
shouldUpdate=
!shallowEqual(prevProps,nextProps)||
!shallowEqual(inst.state,nextState);
}
}
}

{
warning(
shouldUpdate!==undefined,"%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",


this.getName()||'ReactCompositeComponent');

}

this._updateBatchNumber=null;
if(shouldUpdate){
this._pendingForceUpdate=false;
// Will set `this.props`, `this.state` and `this.context`.
this._performComponentUpdate(
nextParentElement,
nextProps,
nextState,
nextContext,
transaction,
nextUnmaskedContext);

}else{
// If it's determined that a component should not update, we still want
// to set props and state but we shortcut the rest of the update.
this._currentElement=nextParentElement;
this._context=nextUnmaskedContext;
inst.props=nextProps;
inst.state=nextState;
inst.context=nextContext;
}

if(callbacks){
for(var j=0;j<callbacks.length;j++){
transaction.
getReactMountReady().
enqueue(callbacks[j],this.getPublicInstance());
}
}
},

_processPendingState:function _processPendingState(props,context){
var inst=this._instance;
var queue=this._pendingStateQueue;
var replace=this._pendingReplaceState;
this._pendingReplaceState=false;
this._pendingStateQueue=null;

if(!queue){
return inst.state;
}

if(replace&&queue.length===1){
return queue[0];
}

var nextState=replace?queue[0]:inst.state;
var dontMutate=true;
for(var i=replace?1:0;i<queue.length;i++){
var partial=queue[i];
var partialState=typeof partial==='function'?
partial.call(inst,nextState,props,context):
partial;
if(partialState){
if(dontMutate){
dontMutate=false;
nextState=babelHelpers.extends({},nextState,partialState);
}else{
babelHelpers.extends(nextState,partialState);
}
}
}

return nextState;
},

/**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactElement} nextElement Next element
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @param {?object} unmaskedContext
   * @private
   */
_performComponentUpdate:function _performComponentUpdate(
nextElement,
nextProps,
nextState,
nextContext,
transaction,
unmaskedContext)
{var _this2=this;
var inst=this._instance;

var hasComponentDidUpdate=!!inst.componentDidUpdate;
var prevProps;
var prevState;
if(hasComponentDidUpdate){
prevProps=inst.props;
prevState=inst.state;
}

if(inst.componentWillUpdate){
{
measureLifeCyclePerf(
function(){return inst.componentWillUpdate(nextProps,nextState,nextContext);},
this._debugID,
'componentWillUpdate');

}


}

this._currentElement=nextElement;
this._context=unmaskedContext;
inst.props=nextProps;
inst.state=nextState;
inst.context=nextContext;

if(inst.unstable_handleError){
this._updateRenderedComponentWithErrorHandling(
transaction,
unmaskedContext);

}else{
this._updateRenderedComponent(transaction,unmaskedContext);
}

if(hasComponentDidUpdate){
{
transaction.getReactMountReady().enqueue(function(){
measureLifeCyclePerf(
inst.componentDidUpdate.bind(inst,prevProps,prevState),
_this2._debugID,
'componentDidUpdate');

});
}







}
},

/**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
_updateRenderedComponentWithErrorHandling:function _updateRenderedComponentWithErrorHandling(transaction,context){
var checkpoint=transaction.checkpoint();
try{
this._updateRenderedComponent(transaction,context);
}catch(e){
// Roll back to checkpoint, handle error (which may add items to the transaction),
// and take a new checkpoint
transaction.rollback(checkpoint);
this._instance.unstable_handleError(e);
if(this._pendingStateQueue){
this._instance.state=this._processPendingState(
this._instance.props,
this._instance.context);

}
checkpoint=transaction.checkpoint();

// Gracefully update to a clean state
this._updateRenderedComponentWithNextElement(
transaction,
context,
null,
true/* safely */);


// Try again - we've informed the component about the error, so they can render an error message this time.
// If this throws again, the error will bubble up (and can be caught by a higher error boundary).
this._updateRenderedComponent(transaction,context);
}
},

/**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
_updateRenderedComponent:function _updateRenderedComponent(transaction,context){
var nextRenderedElement=this._renderValidatedComponent();
this._updateRenderedComponentWithNextElement(
transaction,
context,
nextRenderedElement,
false/* safely */);

},

/**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
_updateRenderedComponentWithNextElement:function _updateRenderedComponentWithNextElement(
transaction,
context,
nextRenderedElement,
safely)
{
var prevComponentInstance=this._renderedComponent;
var prevRenderedElement=prevComponentInstance._currentElement;

var debugID=0;
{
debugID=this._debugID;
}

if(shouldUpdateReactComponent(prevRenderedElement,nextRenderedElement)){
ReactReconciler.receiveComponent(
prevComponentInstance,
nextRenderedElement,
transaction,
this._processChildContext(context));

}else{
var oldHostNode=ReactReconciler.getHostNode(prevComponentInstance);

if(!ReactFeatureFlags.prepareNewChildrenBeforeUnmountInStack){
ReactReconciler.unmountComponent(
prevComponentInstance,
safely,
false/* skipLifecycle */);

}

var nodeType=ReactNodeTypes.getType(nextRenderedElement);
this._renderedNodeType=nodeType;
var child=this._instantiateReactComponent(
nextRenderedElement,
nodeType!==ReactNodeTypes.EMPTY/* shouldHaveDebugID */);

this._renderedComponent=child;

var nextMarkup=ReactReconciler.mountComponent(
child,
transaction,
this._hostParent,
this._hostContainerInfo,
this._processChildContext(context),
debugID);


if(ReactFeatureFlags.prepareNewChildrenBeforeUnmountInStack){
ReactReconciler.unmountComponent(
prevComponentInstance,
safely,
false/* skipLifecycle */);

}

{
if(debugID!==0){
var childDebugIDs=child._debugID!==0?[child._debugID]:[];
ReactInstrumentation.debugTool.onSetChildren(debugID,childDebugIDs);
}
}

this._replaceNodeWithMarkup(
oldHostNode,
nextMarkup,
prevComponentInstance);

}
},

/**
   * Overridden in shallow rendering.
   *
   * @protected
   */
_replaceNodeWithMarkup:function _replaceNodeWithMarkup(oldHostNode,nextMarkup,prevInstance){
ReactComponentEnvironment.replaceNodeWithMarkup(
oldHostNode,
nextMarkup,
prevInstance);

},

/**
   * @protected
   */
_renderValidatedComponentWithoutOwnerOrContext:function _renderValidatedComponentWithoutOwnerOrContext(){
var inst=this._instance;
var renderedElement;

{
renderedElement=measureLifeCyclePerf(
function(){return inst.render();},
this._debugID,
'render');

}



{
// We allow auto-mocks to proceed as if they're returning null.
if(renderedElement===undefined&&inst.render._isMockFunction){
// This is probably bad practice. Consider warning here and
// deprecating this convenience.
renderedElement=null;
}
}

return renderedElement;
},

/**
   * @private
   */
_renderValidatedComponent:function _renderValidatedComponent(){
var renderedElement;



{
ReactCurrentOwner.current=this;
try{
renderedElement=this._renderValidatedComponentWithoutOwnerOrContext();
}finally{
ReactCurrentOwner.current=null;
}
}


invariant(
// TODO: An `isValidNode` function would probably be more appropriate
renderedElement===null||
renderedElement===false||
React.isValidElement(renderedElement),"%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.",


this.getName()||'ReactCompositeComponent');


return renderedElement;
},

/**
   * Lazily allocates the refs object and stores `component` as `ref`.
   *
   * @param {string} ref Reference name.
   * @param {component} component Component to store as `ref`.
   * @final
   * @private
   */
attachRef:function attachRef(ref,component){
var inst=this.getPublicInstance();
invariant(inst!=null,'Stateless function components cannot have refs.');
var publicComponentInstance=component.getPublicInstance();
var refs=inst.refs===emptyObject?inst.refs={}:inst.refs;
refs[ref]=publicComponentInstance;
},

/**
   * Detaches a reference name.
   *
   * @param {string} ref Name to dereference.
   * @final
   * @private
   */
detachRef:function detachRef(ref){
var refs=this.getPublicInstance().refs;
delete refs[ref];
},

/**
   * Get a text description of the component that can be used to identify it
   * in error messages.
   * @return {string} The name or null.
   * @internal
   */
getName:function getName(){
var type=this._currentElement.type;
var constructor=this._instance&&this._instance.constructor;
return(
type.displayName||
constructor&&constructor.displayName||
type.name||
constructor&&constructor.name||
null);

},

/**
   * Get the publicly accessible representation of this component - i.e. what
   * is exposed by refs and returned by render. Can be null for stateless
   * components.
   *
   * @return {ReactComponent} the public component instance.
   * @internal
   */
getPublicInstance:function getPublicInstance(){
var inst=this._instance;
if(
this._compositeType===ReactCompositeComponentTypes.StatelessFunctional)
{
return null;
}
return inst;
},

// Stub
_instantiateReactComponent:null};


module.exports=ReactCompositeComponent;